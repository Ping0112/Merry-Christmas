<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Magic Christmas Memory</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        
        /* Video Camera n·ªÅn */
        #input-video {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            object-fit: cover; z-index: 0;
        }
        
        /* L·ªõp 3D */
        #canvas-container { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            z-index: 1; touch-action: none; 
        }

        /* M√†n h√¨nh ch√†o */
        #start-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); z-index: 999;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: white; text-align: center; padding: 20px; box-sizing: border-box;
        }
        #start-btn {
            padding: 15px 50px; font-size: 18px; background: #d40000; color: white;
            border: 2px solid #ffd700; border-radius: 50px; cursor: pointer;
            margin-top: 25px; font-weight: bold; box-shadow: 0 0 20px rgba(212, 0, 0, 0.6);
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } }

        /* H∆∞·ªõng d·∫´n */
        #hint {
            position: absolute; bottom: 15%; width: 100%; text-align: center;
            color: #ffd700; font-size: 14px; z-index: 10; font-weight: bold;
            text-shadow: 0 2px 4px black; pointer-events: none;
            opacity: 0; transition: opacity 1s;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <video id="input-video" playsinline muted autoplay></video>
    
    <div id="start-overlay">
        <h1 style="color: #ffd700; text-shadow: 0 0 10px orange; margin: 0;">üéÑ H·ªòP QU√Ä K√ù ·ª®C üéÑ</h1>
        <p style="color: #ddd; margin-top: 15px; line-height: 1.6;">
            Ch√†o m·ª´ng b·∫°n ƒë·∫øn v·ªõi kh√¥ng gian Gi√°ng sinh.<br>
            <span style="color: #ffd700; font-weight: bold;">Ch·∫°m & Gi·ªØ tay tr√™n m√†n h√¨nh</span><br>
            ƒë·ªÉ m·ªü h·ªôp qu√† b√≠ m·∫≠t nh√©!
        </p>
        <button id="start-btn">B·∫ÆT ƒê·∫¶U KH√ÅM PH√Å</button>
        <p style="font-size: 11px; color: #777; margin-top: 20px;">*Y√™u c·∫ßu quy·ªÅn Camera ƒë·ªÉ hi·ªÉn th·ªã th·ª±c t·∫ø ·∫£o</p>
    </div>

    <div id="hint">üëÜ Gi·ªØ tay ƒë·ªÉ xem ·∫£nh k·ª∑ ni·ªám</div>
    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';

        // --- C·∫§U H√åNH ---
        const CONFIG = {
            particleCount: 1800, 
            treeHeight: 25, 
            treeRadius: 10,
            ringRadius: 18, // B√°n k√≠nh v√≤ng tr√≤n khi t·∫£n ra ƒë·ªÉ hi·ªán ·∫£nh
            colors: [0xff0000, 0x00ff00, 0xffd700, 0xffffff] 
        };

        let scene, camera, renderer, particles, photoGroup, photoMesh;
        let treePositions = [], ringPositions = [];
        let isTouching = false;
        let imageList = [];
        let loadedTextures = {}; // Cache ·∫£nh ƒë·ªÉ load nhanh h∆°n

        // --- 1. SETUP ---
        document.getElementById('start-btn').addEventListener('click', async () => {
            document.getElementById('start-overlay').style.display = 'none';
            document.getElementById('hint').style.opacity = 1;
            setupCamera();
            init3D();
            loadMediaManifest(); // T·∫£i danh s√°ch ·∫£nh ng·∫ßm
        });

        async function setupCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { facingMode: 'environment' } 
                });
                const video = document.getElementById('input-video');
                video.srcObject = stream;
                video.play();
            } catch (err) {
                console.log("Camera denied:", err);
            }
        }

        async function loadMediaManifest() {
            try {
                const res = await fetch('media/manifest.json');
                const data = await res.json();
                imageList = data.images || [];
                console.log("Loaded images:", imageList);
            } catch (e) { console.warn('Ch∆∞a c√≥ file manifest.json ho·∫∑c l·ªói t·∫£i.'); }
        }

        // --- 2. 3D SCENE ---
        function init3D() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 50);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio > 2 ? 2 : window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            createParticles();
            createPhotoFrame(); // T·∫°o khung ·∫£nh s·∫µn (·∫©n ƒëi)
            setupInteraction();
            animate();
        }

        function createParticles() {
            const posArray = [], colArray = [], sizeArray = [];
            const colorHelper = new THREE.Color();

            for (let i = 0; i < CONFIG.particleCount; i++) {
                const h = i / CONFIG.particleCount; 
                const angle = i * 0.15;
                
                // 1. D√°ng C√¢y Th√¥ng
                const r = (1 - h) * CONFIG.treeRadius + h * 2; 
                const y = (0.5 - h) * CONFIG.treeHeight;
                const x = r * Math.cos(angle * 5 + i);
                const z = r * Math.sin(angle * 5 + i);
                treePositions.push(x, y, z);
                
                // 2. D√°ng V√≤ng Tr√≤n (H√†o quang xung quanh ·∫£nh)
                // T·∫°o th√†nh m·ªôt v√≤ng ring r·ªóng ·ªü gi·ªØa ƒë·ªÉ hi·ªán ·∫£nh
                const ringAngle = Math.random() * Math.PI * 2;
                const ringR = CONFIG.ringRadius + Math.random() * 5; // B√°n k√≠nh l·ªõn
                const ringY = (Math.random() - 0.5) * 30; // Chi·ªÅu cao ng·∫´u nhi√™n
                // √âp c√°c h·∫°t tr√°nh xa t√¢m (n∆°i ƒë·∫∑t ·∫£nh)
                ringPositions.push(
                    ringR * Math.cos(ringAngle), 
                    ringY, 
                    ringR * Math.sin(ringAngle)
                );
                
                // Init buffers
                posArray.push(x, y, z);
                colorHelper.setHex(CONFIG.colors[Math.floor(Math.random() * CONFIG.colors.length)]);
                colArray.push(colorHelper.r, colorHelper.g, colorHelper.b);
                sizeArray.push(Math.random());
            }

            const pGeo = new THREE.BufferGeometry();
            pGeo.setAttribute('position', new THREE.Float32BufferAttribute(posArray, 3));
            pGeo.setAttribute('color', new THREE.Float32BufferAttribute(colArray, 3));
            pGeo.setAttribute('size', new THREE.Float32BufferAttribute(sizeArray, 1));

            const particleMat = new THREE.PointsMaterial({ 
                size: 0.8, vertexColors: true, blending: THREE.AdditiveBlending, 
                depthWrite: false, transparent: true, opacity: 0.9 
            });

            particles = new THREE.Points(pGeo, particleMat);
            scene.add(particles);
        }

        function createPhotoFrame() {
            photoGroup = new THREE.Group();
            
            // T·∫°o khung vi·ªÅn v√†ng
            const frameGeo = new THREE.PlaneGeometry(16.5, 12.5); // T·ªâ l·ªá 4:3 + vi·ªÅn
            const frameMat = new THREE.MeshBasicMaterial({ color: 0xffd700 });
            const frameMesh = new THREE.Mesh(frameGeo, frameMat);
            frameMesh.position.z = -0.1; // ƒê·∫∑t ra sau ·∫£nh ch√∫t
            photoGroup.add(frameMesh);

            // T·∫°o ch·ªó hi·ªÉn th·ªã ·∫£nh
            const geo = new THREE.PlaneGeometry(16, 12);
            const mat = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0 });
            photoMesh = new THREE.Mesh(geo, mat);
            photoGroup.add(photoMesh);

            photoGroup.visible = false; // M·∫∑c ƒë·ªãnh ·∫©n
            scene.add(photoGroup);
        }

        function showRandomPhoto() {
            if (imageList.length === 0) return;
            
            // Random ·∫£nh
            const imgName = imageList[Math.floor(Math.random() * imageList.length)];
            const imgPath = `media/${imgName}`;

            const textureLoader = new THREE.TextureLoader();
            
            // H√†m update texture
            const updateTex = (tex) => {
                photoMesh.material.map = tex;
                
                // T·ª± ƒë·ªông ch·ªânh t·ªâ l·ªá khung theo ·∫£nh
                const aspect = tex.image.width / tex.image.height;
                // Gi·ªØ chi·ªÅu cao c·ªë ƒë·ªãnh l√† 12, t√≠nh chi·ªÅu r·ªông
                const newWidth = 12 * aspect;
                photoMesh.scale.set(aspect, 1, 1); 
                
                // Ch·ªânh l·∫°i vi·ªÅn v√†ng ph√≠a sau cho v·ª´a ·∫£nh
                photoGroup.children[0].scale.set(aspect * 1.05, 1.05, 1);
                
                photoMesh.material.needsUpdate = true;
            };

            // Ki·ªÉm tra cache xem ƒë√£ t·∫£i ch∆∞a
            if (loadedTextures[imgPath]) {
                updateTex(loadedTextures[imgPath]);
            } else {
                textureLoader.load(imgPath, (tex) => {
                    loadedTextures[imgPath] = tex;
                    updateTex(tex);
                });
            }

            photoGroup.visible = true;
        }

        // --- 3. T∆Ø∆†NG T√ÅC ---
        function setupInteraction() {
            const onDown = () => { 
                if(!isTouching) {
                    isTouching = true; 
                    showRandomPhoto();
                    document.getElementById('hint').style.opacity = 0; // ·∫®n h∆∞·ªõng d·∫´n
                }
            };
            const onUp = () => { 
                isTouching = false; 
                // Kh√¥ng ·∫©n ngay photoGroup ƒë·ªÉ cho hi·ªáu ·ª©ng fade out trong animate x·ª≠ l√Ω
            };

            window.addEventListener('pointerdown', onDown);
            window.addEventListener('pointerup', onUp);
            // H·ªó tr·ª£ c·∫£ touch
            window.addEventListener('touchstart', onDown);
            window.addEventListener('touchend', onUp);

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        // --- 4. ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);

            // 1. X·ª≠ l√Ω H·∫°t (Particles)
            const positions = particles.geometry.attributes.position.array;
            const target = isTouching ? ringPositions : treePositions; // Ch·ªçn ƒë√≠ch ƒë·∫øn
            const lerpSpeed = isTouching ? 0.05 : 0.08; // T·∫£n ra ch·∫≠m, t·ª• l·∫°i nhanh

            for (let i = 0; i < CONFIG.particleCount * 3; i++) {
                positions[i] += (target[i] - positions[i]) * lerpSpeed;
            }
            particles.geometry.attributes.position.needsUpdate = true;

            // 2. X·ª≠ l√Ω ·∫¢nh (Fade In/Out)
            if (isTouching) {
                // Fade In
                if (photoMesh.material.opacity < 1) photoMesh.material.opacity += 0.05;
                photoGroup.scale.setScalar(THREE.MathUtils.lerp(photoGroup.scale.x, 1, 0.1)); // Zoom in nh·∫π
                particles.rotation.y += 0.002; // Xoay ch·∫≠m khi xem ·∫£nh
            } else {
                // Fade Out
                if (photoMesh.material.opacity > 0) {
                    photoMesh.material.opacity -= 0.1;
                } else {
                    photoGroup.visible = false; // ·∫®n h·∫≥n khi ƒë√£ trong su·ªët
                }
                photoGroup.scale.setScalar(0.8); // Reset zoom
                particles.rotation.y += 0.01; // Xoay nhanh khi l√† c√¢y
            }

            // Hi·ªáu ·ª©ng l·∫•p l√°nh h·∫°t
            const sizes = particles.geometry.attributes.size.array;
            for(let i=0; i < CONFIG.particleCount; i++){
                sizes[i] = 0.5 + 0.5 * Math.sin(Date.now() * 0.005 + i);
            }
            particles.geometry.attributes.size.needsUpdate = true;

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>